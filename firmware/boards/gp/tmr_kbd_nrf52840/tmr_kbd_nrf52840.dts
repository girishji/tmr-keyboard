/dts-v1/;

#include <nordic/nrf52840_qiaa.dtsi>
#include <nordic/nrf52840_partition.dtsi>
#include "tmr_kbd_nrf52840-pinctrl.dtsi"
#include <dt-bindings/regulator/npm13xx.h>
/* Include keycode definitions */
#include <zephyr/dt-bindings/input/input-event-codes.h>

/ {
	model = "TMR Keyboard";
	compatible = "gp,tmr-kbd-nrf52840";

	chosen {
		/* Redirect console to Seggar RTT to save pins */
		zephyr,console = &snippet_rtt;
		zephyr,shell-uart = &snippet_rtt;
		zephyr,uart-mcumgr = &snippet_rtt;
	};

	/* Virtual RTT console node */
	snippet_rtt: snippet_rtt {
		compatible = "segger,rtt-uart";
	};
};

/ {
	/* Expose ADC inputs to application */
	zephyr,user {
		io-channels =
			<&adc 0>, /* ADC device, channel 0 */
			<&adc 1>,
			<&adc 2>,
			<&adc 3>,
			<&adc 4>,
			<&adc 5>,
			<&adc 6>,
			<&adc 7>;
	};

	/* This allows ADC to be referred as: DT_ALIAS(adc0), instead of knowing the full path */
	aliases {
		adc0 = &adc;
	};

	/* Define MUX control pins as a new group */
	mux_control {
		compatible = "gpio-leds"; /* generic gpio driver */
		mux_a0: mux_a0 {
			gpios = <&gpio0 17 GPIO_ACTIVE_HIGH>;
		};
		mux_b0: mux_b0 {
			gpios = <&gpio0 6 GPIO_ACTIVE_HIGH>;
		};
		mux_b1: mux_b1 {
			gpios = <&gpio0 7 GPIO_ACTIVE_HIGH>;
		};
		mux_b2: mux_b2 {
			gpios = <&gpio1 8 GPIO_ACTIVE_HIGH>;
		};
	};
};

/* Define the physical GPIO connection for the MUX-style signal if needed */
/ {
	npm_pins {
		compatible = "gpio-leds";
		/* P0.15 is physically wired to the output of LDSW1/GPIO2 */
		ldsw_monitor: ldsw_monitor {
			gpios = <&gpio0 15 GPIO_ACTIVE_HIGH>;
		};
		/* P0.16 is connected to GPIO3 of nPM1300 */
		pmic_gpio3_link: pmic_gpio3_link {
			gpios = <&gpio0 16 GPIO_ACTIVE_HIGH>;
		};
	};
};

/* Configure the I2C0 Bus and Peripherals */
&i2c0 {
	status = "okay";
	pinctrl-0 = <&i2c0_default>;
	pinctrl-1 = <&i2c0_sleep>;
	pinctrl-names = "default", "sleep";
	/* clock-frequency = <I2C_BITRATE_FAST>; */

	/* npm1300: pmic@48 { */
	npm1300: pmic@6b {
		compatible = "nordic,npm1300";
		reg = <0x6b>;
		/* INT (GPIO1) of nPM1300 connected to P0.14 */
		host-int-gpios = <&gpio0 14 GPIO_ACTIVE_LOW>;
		/* host-int-gpios = <&gpio0 14 GPIO_ACTIVE_HIGH>; */
		pmic-int-pin = <1>;

		npm1300_gpio: gpio-controller {
			compatible = "nordic,npm1300-gpio";
			gpio-controller;
			#gpio-cells = <2>;
			ngpios = <5>;
		};

		npm1300_regulators: regulators {
			compatible = "nordic,npm1300-regulator";

			/* Main MCU Power - Stays on, 1.8v*/
			npm1300_buck1: BUCK1 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <1800000>;
				regulator-boot-on;
				regulator-always-on;
			};

			/* TMR Sensor Power Source, 1.8v */
			npm1300_buck2: BUCK2 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <1800000>;
				regulator-always-on;
				regulator-boot-on;
			};

			/* The Load Switch (LDO1) controlled by GPIO2 */
			npm1300_ldsw1: LDO1 {
				regulator-initial-mode = <NPM13XX_LDSW_MODE_LDSW>;
				regulator-allowed-modes = <NPM13XX_LDSW_MODE_LDSW>;
				/* Link to GPIO2 internally */
				enable-gpio-config = <2 GPIO_ACTIVE_HIGH>;
				regulator-boot-off;
			};

			npm1300_ldsw2: LDO2 {
				status = "disabled";
			};
		};

		npm1300_charger: charger {
			compatible = "nordic,npm1300-charger";
			term-microvolt = <4150000>;     /* 4.15V max charge */
			term-warm-microvolt = <4000000>;
			current-microamp = <150000>;    /* 150mA default */
			dischg-limit-microamp = <1000000>;
			vbus-limit-microamp = <500000>;
			thermistor-ohms = <10000>;      /* Enabled NTC */
			thermistor-beta = <3380>;
			charging-enable;
		};
	};

	/* LED IC */
	lp5864: lp5864@10 {
		/* compatible = "i2c-device"; */
		compatible = "ti,lp586x"; /* Hypothetical binding name */
		reg = <0x10>;
		/* EN pin connected to P0.13 */
		enable-gpios = <&gpio0 13 GPIO_ACTIVE_HIGH>;
	};
};

/* Enable ADC for your TMR sensors */
&adc {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";

	channel@0 {
		reg = <0>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL"; /* 0.6V internal ref */
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN0>; /* P0.02 */
		zephyr,resolution = <12>;
		/* optional oversampling: take 4 samples and average them (less noise, but adc stays on longer) */
		/* zephyr,oversampling = <4>; */
	};

	channel@1 {
		reg = <1>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN1>; /* P0.03 */
		zephyr,resolution = <12>;
	};

	channel@2 {
		reg = <2>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN2>; /* P0.04 */
		zephyr,resolution = <12>;
	};

	channel@3 {
		reg = <3>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN3>; /* P0.05 */
		zephyr,resolution = <12>;
	};

	channel@4 {
		reg = <4>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN4>; /* P0.28 */
		zephyr,resolution = <12>;
	};

	channel@5 {
		reg = <5>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN5>; /* P0.29 */
		zephyr,resolution = <12>;
	};

	channel@6 {
		reg = <6>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN6>; /* P0.30 */
		zephyr,resolution = <12>;
	};

	channel@7 {
		reg = <7>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN7>; /* P0.31 */
		zephyr,resolution = <12>;
	};
};

/* Enable GPIO Ports */
&gpio0 {
	status = "okay";
};

&gpio1 {
	status = "okay";
};

/* Disable everything you aren't using to save power/resources */
&uart0 { status = "disabled"; };
&uart1 { status = "disabled"; };
&i2c1 { status = "disabled"; };
&spi0 { status = "disabled"; };
&spi1 { status = "disabled"; };
&spi2 { status = "disabled"; };
&pwm0 { status = "disabled"; };
&qspi { status = "disabled"; };

/* Keep USB enabled for the keyboard connection */
zephyr_udc0: &usbd {
	status = "okay";
};
