Battery operation is not viable. TMR sensors draw 165uA (NVA sensor), and
240-300uA (MDT sensor). For 72 sensors it will be ~20mA. This will make 4000mAh
battery last less than 2 weeks. However, power on time for MDT is listed as
100us. Maybe pulsing the sensor will save current. It takes 5-10us for mcu to
detect digital signal, so the sensor can be pulsed every 10ms, and kept on for
100+10us (0.11ms). It saves about 100x power (duty cycle = 110us/10ms).
You can even push this to 25ms polling during deep sleep.
However this requires MCU wake up and poll every 10ms.
Or use Dedicated Low-Power Timer Circuit (Timer IC e.g., Texas Instruments
TPL5010 or TPL5111) (pulse is connected to the Enable pin of a MOSFET)
Or, you can use nrf52x:
    "Every nRF52 MCU (including the popular nRF52840 and nRF52832 is designed to
    allow the RTC (timer) to run while the main CPU core is
    asleep. This is the standard, highly efficient way to implement periodic
    polling in ultra-low power wireless applications like your keyboard."

---
---

Circuits:
- battery
- PMIC if needed
- open-drain (not push-pull) comparator (MCP6546, MCP6549)
- gemini suggests super low current TLV704x comparators from TI (https://www.tme.eu/pl/details/tlv7042dsgr/komparatory-smd/texas-instruments/)
- a device to produce precise voltage to compare against
- something to OR these outputs and feed into SENSE gpio pin of nrf
- a circuit to scan the digital outputs (from mcu)

---
---

Q: can nrf be used to pulse TMR sensors

Yes, absolutely. This is one of the core strengths and design philosophies of the $\text{nRF}52$ series of microcontrollers, particularly when used in low-power wireless applications like keyboards.

The $\text{nRF}52$ MCUs use a sophisticated power management system that allows the main CPU core (the $\text{ARM}$ $\text{Cortex}$-$\text{M}$ series processor) to enter a deep sleep state while specific, ultra-low power peripherals remain running.

Here is how the $\text{nRF}52$ achieves a low-power timer for pulsing sensors:

## ðŸ’¤ System $\text{ON}$ Low-Power Mode

The $\text{nRF}52$ MCUs spend most of their time in the **System $\text{ON}$ low-power mode**. Within this mode, the CPU can execute a **`WFE` (Wait For Event)** or **`WFI` (Wait For Interrupt)** instruction, putting the core into a deep sleep state.

The key to your requirement is the use of the **Low-Frequency Clock (LFCLK)** domain.

### 1. The Low-Frequency Clock (LFCLK)

The $\text{nRF}52$ family has two primary clock sources:

* **High-Frequency Clock ($\text{HFCLK}$):** Used to run the main $\text{CPU}$ core and the high-speed peripherals (like $\text{Bluetooth}$) at full speed ($\approx 64 \text{ MHz}$). This is powered down in sleep mode.
* **Low-Frequency Clock ($\text{LFCLK}$):** Used to run the ultra-low power peripherals at $\mathbf{32.768 \text{ kHz}}$. This clock can remain running with extremely low power consumption (drawing only a few nanoamperes) while the $\text{CPU}$ is sleeping.

### 2. The RTC (Real-Time Counter) Peripheral

The $\text{nRF}52$ uses its **$\text{RTC}$ (Real-Time Counter)** peripheral, which is driven by the $\text{LFCLK}$, as the core timing mechanism.

* The $\text{RTC}$ is designed to operate continuously.
* You configure the $\text{RTC}$ to generate an **interrupt** every $10 \text{ ms}$.
* When the $\text{CPU}$ is sleeping, the $\text{RTC}$ continues to count. When the $10 \text{ ms}$ target is reached, the $\text{RTC}$ generates a wake-up signal (an interrupt).

### 3. The Pulsing Procedure

The entire process for pulsing your $\text{TMR}$ sensor every $10 \text{ ms}$ while minimizing power consumption is handled by the $\text{MCU}$'s architecture:

| Time | MCU State | Action | Power Consumption |
| :--- | :--- | :--- | :--- |
| **$0 \text{ ms}$** | **Wakes Up** | $\text{RTC}$ interrupt fires. $\text{CPU}$ wakes up. | $\text{High}$ ($\text{mA}$) |
| **$0 \to 100 \mu\text{s}$**| **Active** | 1. $\text{CPU}$ sets $\text{GPIO}$ HIGH (power on sensor). 2. $\text{CPU}$ enters short $100 \mu\text{s}$ delay. 3. $\text{CPU}$ reads sensor data. 4. $\text{CPU}$ sets $\text{GPIO}$ LOW (power off sensor). | $\text{High}$ ($\text{mA}$) |
| **$100 \mu\text{s}$ to $10 \text{ ms}$** | **Deep Sleep** | $\text{CPU}$ executes `WFE`/`WFI`. $\text{CPU}$ sleeps. **$\text{RTC}$ continues counting.** | **Ultra-Low** ($\mu\text{A}$) |

---

## Conclusion

Every $\text{nRF}52\text{x}$ $\text{MCU}$ (including the popular $\text{nRF}52840$ and $\text{nRF}52832$) is designed to allow the **$\text{RTC}$ (timer) to run while the main $\text{CPU}$ core is asleep**. This is the standard, highly efficient way to implement periodic polling in ultra-low power wireless applications like your keyboard.

The power consumption of the $\text{nRF}52$ in this sleep state is typically in the **low single-digit microamperes** ($2 \mu\text{A}$ to $5 \mu\text{A}$), which is the most efficient solution available for this task.

---
---

Q: i have 72 analog outputs , how to determing if any of them are above a certain voltage threshold (say 1v), power supply is 3.3v

Nice â€” youâ€™ve got 72 analog channels and want a single digital flag that tells you **â€œany channel > 1.00 Vâ€** with a 3.3 V supply. Below I give practical architectures, recommended topology, power/response tradeoffs, calculations (pull-up, currents), an ASCII schematic for the simplest option, and extra tips (hysteresis, programmable threshold). Pick the approach that matches your power and latency needs.

---

# Best overall approach (simple, scalable, robust)

**Use one comparator per channel (in quad packages) whose outputs are open-drain, tie all comparator outputs together to one node with a single pull-up to 3.3 V. Use a single precision 1.00 V reference (or an IÂ²C DAC for a programmable threshold) as the reference input to every comparator.**
This yields a single wired-OR (active-low) line: *LOW = at least one channel > threshold*.

Why this is good

* No bus contention (open-drain wired-OR is safe).
* Very simple: 72 comparators, 1 pull-up, 1 reference.
* Instant response (comparator-level latency, Âµs or faster).
* Threshold is programmable if your ref comes from an IÂ²C DAC.

---

# Block diagram (concept)

```
  A1 ---+> COMP1 ---+ \
  A2 ---+> COMP2 ---+  \            +---> OR_NODE ----> MCU input (or LED/logic)
   .           ...       >---wired-OR|
  A72--+> COMP72---+ /             |
                                     \
                                      - pull-up to 3.3 V (Rpul)
Reference (1.00V or DAC) ----------/  (comparator negative input)
```

Each comparator compares Ai (positive input) vs Vref (negative). Comparator outputs must be open-drain/open-collector (or you choose comparator products that have open-drain outputs). Tie outputs together to OR_NODE and add single pull-up to 3.3 V. The line is **active-low** (LOW = some channel > Vref).

---

# Example comparator wiring (single channel)

* COMP+ = sensor analog channel
* COMPâˆ’ = VREF (1.00 V from precision ref or DAC)
* COMP OUTPUT = open-drain â†’ tied to OR_NODE
* OR_NODE pulled up to 3.3 V with Rpul

Add small hysteresis (optional) using the comparatorâ€™s built-in hysteresis or external positive feedback network per comparator.

---

# Parts strategy

* Use **quad comparators** (one IC contains 4 comparators) to reduce PCB count. You need `ceil(72/4) = 18` quad ICs.
* Choose comparators with:

  * **Open-drain / open-collector outputs** (for safe wired-OR).
  * **Input common-mode includes ground and 1.00 V** (with 3.3 V supply).
  * **Low quiescent current per comparator** if power is critical (ÂµA per comparator preferred).
  * Built-in hysteresis or a way to add a small hysteresis externally.
* For **programmable threshold**, use a single small IÂ²C DAC (e.g., 8â€“12 bit) or precision voltage reference + op-amp buffer to generate the 1.00 V reference. Drive the DAC value from your MCU to change threshold at runtime.
* If board area is tight, consider dual or octal comparator packages instead â€” but ensure they have open-drain outputs.

(If you want, I can recommend specific low-power comparator IC families and a DAC that match `3.3 V` and have open-drain outputs. Say â€œyesâ€ and Iâ€™ll list candidates.)

---

# Pull-up sizing and power numbers

You need to choose Rpul to trade off rise time vs current when the line is pulled low.

1. **Pull-up current when the OR node is LOW** (one or more comparators actively pulling low):
   [
   I_{pul_low} = \frac{V_{pullup}}{R_{pul}} = \frac{3.3\text{ V}}{R_{pul}}
   ]

Examples:

* Rpul = 10 kÎ© â†’ I â‰ˆ 330 ÂµA (when node = 0 V)
* Rpul = 22 kÎ© â†’ I â‰ˆ 150 ÂµA
* Rpul = 100 kÎ© â†’ I â‰ˆ 33 ÂµA

2. **Rise time**: node capacitance Cnode (PCB traces + comparator output capacitances) matters. Time constant Ï„ = Rpul Ã— Cnode. For approximate rise to logic HIGH (~3Ï„) use desired rise time to size Rpul.

Example: if Cnode â‰ˆ 200 pF and you want ~30 Âµs rise (3Ï„), then Ï„ â‰ˆ 10 Âµs â†’ Rpul â‰ˆ 10e-6 / 200e-12 = 50 kÎ©. So Rpul â‰ˆ 47â€“56 kÎ© gives ~30 Âµs.

Choose Rpul around **10 kÎ©â€“47 kÎ©** typically; lower for faster response, higher for lower average current.

3. **Quiescent current (no channel asserted)**: practically zero from Rpul. Total idle power dominated by comparator quiescent currents (see next section).

---

# Power budget: comparator quiescent current

* If you pick comparators with e.g. **5 ÂµA per comparator** (per device or per channel depending on part), total for 72 channels = 72 Ã— 5 ÂµA = 360 ÂµA. At 3.3 V that's â‰ˆ 1.2 mW.
* If comparator per channel is 1 ÂµA â†’ total 72 ÂµA (â‰ˆ 0.24 mW).
* **So pick comparators with ÂµA-class quiescent currents** if battery life matters. The pull-up current only flows when OR_NODE is LOW.

---

# Hysteresis / debouncing

* Add **hysteresis** to each comparator to avoid chatter around 1.00 V (either using comparator internal hysteresis or small external positive feedback network). Target ~10â€“50 mV hysteresis depending on sensor noise.
* If channels can glitch briefly, either implement a tiny RC filter on each analog channel (affects response) or sample the OR_NODE in MCU and confirm low for a small window (debounce).

---
---

Q: typical circuit for mcp6546 comparator

The **MCP6546** is a **single, low-power comparator** with a key feature being its **open-drain output**. A typical circuit for this comparator will always include an **external pull-up resistor** on the output pin to establish the high logic level.

The most common applications for the MCP6546 are as a basic **voltage comparator** (non-inverting or inverting), often with hysteresis to prevent oscillation from noise.

---

## ðŸ”Œ Core Open-Drain Comparator Circuit

The basic circuit configuration for the MCP6546 involves:

1.  **Power Supply:** Connecting the $V_{DD}$ pin to the positive power supply (1.6V to 5.5V) and $V_{SS}$ (or GND) to the negative supply/ground.
2.  **Input Voltages:** Applying the two voltages to be compared to the **inverting input** ($V_{IN-}$ or pin 2 on SOT-23-5) and the **non-inverting input** ($V_{IN+}$ or pin 3 on SOT-23-5).
3.  **Output Circuit:** Connecting an **external pull-up resistor ($R_L$)** from the **Output pin (OUT)** to a **pull-up voltage ($V_{PULLUP}$)**.


* **Open-Drain Output:** The output transistor of the MCP6546 acts like a switch to $V_{SS}$ (ground).
    * If $V_{IN+} > V_{IN-}$, the output transistor is **OFF**, and the output pin is pulled high to $V_{PULLUP}$ by $R_L$.
    * If $V_{IN+} < V_{IN-}$, the output transistor is **ON**, connecting the output pin to $V_{SS}$ (low).
* **Level Shifting:** Because the output is open-drain, $V_{PULLUP}$ can be up to **10V**, even if the comparator's supply voltage ($V_{DD}$) is as low as 1.6V. This makes the MCP6546 excellent for interfacing to higher-voltage logic circuits.

---

## ðŸ›¡ï¸ Inverting Comparator with Hysteresis (Schmitt Trigger)

To prevent the output from rapidly switching (oscillating) when the input voltage is near the reference voltage, a typical circuit will incorporate **hysteresis** using two external resistors, $R_1$ and $R_2$.

This is a very common circuit for the MCP6546, especially in noise-sensitive applications like battery monitoring.

### Circuit Setup
* The **non-inverting input ($V_{IN+}$)** is connected to a fixed **reference voltage ($V_{REF}$)** (e.g., from a voltage divider or reference IC).
* The **inverting input ($V_{IN-}$)** is connected to the **input signal ($V_{IN}$)** through a feedback network consisting of $R_1$ and $R_2$. $R_2$ connects the output (OUT) back to $V_{IN-}$.

### Operation
The comparator switches its output when the input signal $V_{IN}$ crosses one of two thresholds:

1.  **Upper Threshold Voltage ($V_{TH+}$):** The output switches from **High to Low** when $V_{IN}$ rises above $V_{TH+}$.
2.  **Lower Threshold Voltage ($V_{TH-}$):** The output switches from **Low to High** when $V_{IN}$ drops below $V_{TH-}$.

The difference between $V_{TH+}$ and $V_{TH-}$ is the **hysteresis voltage**.

---

## ðŸ”‹ Typical Application: Battery Monitor

A highly typical use for the low-power MCP6546 is as a **low-battery detection circuit**.

* $V_{DD}$ is connected directly to the **battery voltage ($V_{BATTERY}$)**.
* A stable **reference voltage ($V_{REF}$)**, which is the "low-battery" threshold, is applied to one input (e.g., $V_{IN+}$).
* $V_{BATTERY}$ is typically applied (sometimes divided) to the other input ($V_{IN-}$).

When $V_{BATTERY}$ drops below $V_{REF}$, the output switches, signaling a low-battery condition. The low quiescent current ($\text{600 nA}$) of the MCP6546 is ideal for continuously monitoring a battery without draining it.


---
---

Q: does nordic make a ldo for low power operations

Good question. Yes â€” Nordic Semiconductor does offer dedicated power-management ICs (PMICs) that provide LDO (and other) regulation, designed for low-power and battery-operated devices. ([nordicsemi.com][1])

### âœ… Nordicâ€™s PMIC solutions with LDO / low-power support

* **nPM2100** â€” a newer PMIC from Nordic. It includes a highly efficient boost regulator (for raising battery voltage to a usable rail) and a built-in LDO / load-switch output that can supply up to ~50 mA. ([nordicsemi.com][2])
* **nPM1300** â€” an earlier Nordic PMIC, providing multiple regulated rails via external DC/DC or LDO regulators. It integrates 2 step-down DC/DC converters plus 2 LDO regulators, battery charging and power-path management, meant to simplify supply design for Nordic SoCs. ([electronicsforu.com][3])

These PMICs are explicitly targeted at battery-powered, low-power embedded designs (e.g. wearables, sensors, BLE modules), and are well suited to use with Nordic SoCs (e.g. the nRF52840) to supply the MCU, radios, sensors, and optionally external modules â€” all under a unified, power-efficient supply solution. ([nordicsemi.com][1])

### âš  Why use external PMIC instead of internal regulators

* The internal regulators (LDO or DC-DC) of the nRF52840 only power the SoC itself â€” they are not meant to supply external sensors or modules.
* External PMICs (like nPM2100 or nPM1300) are designed to supply both the MCU *and* any external peripherals, and often support features like battery charging, power-path switching, load-switching, and ultra-low quiescent current (important for battery life).
* For low-power, battery-operated designs, using such a PMIC helps minimize leakage, manage power rails properly, provide clean regulation, and simplify overall power architecture.



Good â€” hereâ€™s a list of several PMIC / LDO / regulator ICs (from Nordic Semiconductor *and* other vendors) that are well suited for battery-powered designs with an MCU like nRF52840 + sensors. I grouped them roughly by typical use-case / trade-offs (ultra-low power, simple LDO, buck/boost, more integrated PMIC).

---

## âœ… From Nordic (very well matched to nRF + BLE + battery)

* **nPM2100** â€” boost regulator + LDO/load-switch ideal for single-cell or coin-cell battery powered BLE devices. Input range 0.7â€“3.4 V, output 1.8â€“3.3 V, up to 150 mA (boost) or 50 mA (LDO), quiescent current down to ~150 nA. Supports â€œship/hibernateâ€ modes for ultra-low standby draw. ([nordicsemi.com][1])
* **nPM1300** â€” more feature-rich PMIC with dual buck regulators (each up to 200 mA), 2 LDO/load switches (50 mA), battery charger, fuel-gauge, system management, USB-charging support. Good when you want to support rechargeable battery + regulated rails + external sensors/modules. ([docs-be.nordicsemi.com][2])

**Why these are good:** They are designed specifically for use with nRF-series SoCs, support typical battery chemistries, handle both boost (for low-voltage cells) and buck/LDO, include power-management features like ship mode (very low quiescent), and even battery charging / fuel gauge in nPM1300.

---

### Quick notes on some:

* **[STMicroelectronics LD2980ABM33TR](https://estore.st.com/en/ld2980abm33tr-cpn.html?utm_source=chatgpt.com)** â€” simple 3.3 V LDO regulator, small, low cost, good for powering sensors or small peripherals when your battery is modestly above 3.3 V.
* **[STMicroelectronics LD2981ABU33TR](https://estore.st.com/en/ld2981abu33tr-cpn.html?utm_source=chatgpt.com)** â€” another low-dropout 3.3 V regulator variant â€” useful when you need a stable 3.3 V rail for sensors or logic and battery max ~4.2 V (like Li-ion).
* **[1â€¯A Low Quiescent Current Lowâ€‘Noise Voltage Regulator](https://www.electromaker.io/shop/product/1-a-low-quiescent-current-low-noise-voltage-regulator-with-soft-start-automotive-grade?utm_source=chatgpt.com)** â€” for slightly heavier loads or peripherals needing more current, but within modest current consumption range.
* **[Texas Instruments TPS62665YFFT](https://www.utmel.com/productdetail/texasinstruments-tps62665yfft-7763667?utm_source=chatgpt.com)** â€” a buck converter / PMIC (not just LDO) â€” more efficient than LDO at higher currents or when battery is significantly above the required rail, useful if you care about efficiency and battery life.

**Good for:** powering sensors or small modules when you want regulated 3.0â€“3.3 V and donâ€™t need all the bells & whistles of a full PMIC. Often simpler, cheaper, and with lower board footprint.

---

## âš™ï¸ When to pick which kind of regulator / PMIC

| Situation                                                                                                                        | Recommended type                                     |
| -------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| Single-cell coin battery / AA / small battery; need boost + regulated rail + lowest quiescent current + simple BLE + sensors     | nPM2100                                              |
| Rechargeable battery (Li-ion, Li-Po), need charging, multiple rails for MCU + sensors + maybe peripherals (display, radio, etc.) | nPM1300                                              |
| Already have a stable battery volt > needed sensor voltage, need simple 3.3 V supply for sensor/peripherals                      | Simple LDO (e.g. LD2980, LD2981)                     |
| Medium to high current draw, and efficiency matters (battery life, heat)                                                         | Buck converter / efficient regulator (e.g. TPS62665) |
| Low current, noise-sensitive sensors or analog modules needing clean 3.3 V rail                                                  | Low-noise LDO                                        |

---

## ðŸ“Œ My recommendation (based on what youâ€™ve told me so far)

Since you are using nRF + battery + external sensors, but likely want to keep overall current low and battery life high:

* If you want **maximum simplicity and lowest quiescent current** â†’ go with **nPM2100**.
* If you plan a **rechargeable design**, or multiple peripherals (sensors, maybe display, sensor array) â†’ choose **nPM1300**.
* If you just need to power a small sensor from e.g. a Li-ion battery â†’ a simple 3.3 V LDO like **LD2981** or **LD2980** might suffice.
* If your sensor or peripherals draw non-trivial current periodically (e.g. 50â€“200 mA bursts) â†’ consider a buck converter like **TPS62665** for efficiency.


---
---

Based on your usage requirements, the **maximum average power** the LED matrix can draw during active use is approximately **$232 \text{ mW}$** (or $62.7 \text{ mA}$ average current).

This calculation assumes a nominal battery voltage of **$3.7\text{V}$** (typical for Li-ion/Li-Po) and accounts for the power consumed by the microcontroller and LED driver chip.

---

## 1. Required Active Current Calculation

The $4000 \text{mAh}$ battery must supply all the current needed for one week, with $56$ hours of active use. We assume the system is in deep sleep for the remaining time, making the sleep current negligible.

| Parameter | Value | Calculation |
| :--- | :--- | :--- |
| **Total Active Usage Time** | $56 \text{ hours}$ | $7 \text{ days} \times 8 \text{ hours/day}$ |
| **Max Total Active Current** | $\approx 71.43 \text{ mA}$ | $\frac{4000 \text{ mAh}}{56 \text{ h}}$ |
| **Estimated System Overhead** | $\approx 8.77 \text{ mA}$ | Current for MCU (nRF52840, $\approx 6.6 \text{ mA}$) + LED Driver (IS31FL3731 quiescent, $\approx 2.17 \text{ mA}$) |
| **Max Average LED Matrix Current** | **$\approx 62.66 \text{ mA}$** | $71.43 \text{ mA} - 8.77 \text{ mA}$ |

---

## 2. Maximum Average LED Matrix Power

Using the calculated maximum current and the battery's nominal voltage ($\text{V}_{\text{batt}}=3.7\text{V}$):

$$\text{P}_{\text{max}} = \text{I}_{\text{LED\_max}} \times \text{V}_{\text{batt}}$$
$$\text{P}_{\text{max}} = 62.66 \text{ mA} \times 3.7\text{V} \approx 231.84 \text{ mW}$$

Therefore, the maximum power the LED matrix can draw is **$231.84 \text{ mW}$** on average during your 8 hours of daily use.

---

## Practical Implication for Brightness

To put the $\mathbf{62.66 \text{ mA}}$ maximum average current into context using the **IS31FL3731** driver (as discussed previously, which drives a $16 \times 9$ matrix with 144 LEDs):

* The IS31FL3731 draws $\approx 180 \text{ mA}$ when all 144 LEDs are driven at their **maximum average brightness** (assuming a $20 \text{k}\Omega$ external resistor).

Since your allowed current ($62.66 \text{ mA}$) is significantly **lower** than the maximum possible draw ($180 \text{ mA}$), you would have to **limit the brightness** of your LED matrix to maintain the week-long battery life.

$$\text{Max Brightness Percentage} \approx \frac{62.66 \text{ mA}}{180 \text{ mA}} \approx 34.8\%$$

You would need to set the software dimming register to a level equivalent to about **$35\%$** of the maximum possible brightness for the whole matrix to last a week.

---
---

Here are the **typical real-world current-draw numbers** for an **nRF52840 running ZMK**, based on common keyboard PCB designs (nice!nano v2, ZMK power-profiles, etc.):

---

## âœ… **Normal Current Draw for nRF52840 in ZMK**

These are *typical* values when the board is configured correctly (deep sleep, no OLED, no extra sensors):

### **Idle (deep sleep / standby)**

* **8â€“15 ÂµA** for a fully optimized ZMK build
* **20â€“40 ÂµA** is common on real boards with regulators, power rails, etc.
* A poorly designed PCB or ESD chips may raise this into the **80â€“200 ÂµA** range.

### **Advertising (BLE not connected)**

* **150â€“450 ÂµA average**, depending on:

  * Advertising interval
  * TX power setting
  * Board hardware setup

### **Connected (normal operation)**

* **90â€“300 ÂµA average** with:

  * Standard ZMK BLE connection interval
  * No heavy peripherals
  * Keyboard idle (no keypresses)

### **Active typing**

* **1â€“3 mA** momentary peaks
* Very briefâ€”average over time stays low.

### **Absolute peak events**

* **5â€“8 mA** radio TX spike
* Only milliseconds long
* Doesnâ€™t significantly affect average battery life.

---

## ðŸ”§ Factors that increase current draw

* OLED screens (20â€“30 mA)
* RGB underglow/LEDs (10â€“80+ mA depending on count)
* Poor regulator quiescent current (15â€“200+ ÂµA depending on PCB)
* Incorrect ZMK power settings
* Sensors (PMW3360, battery gauge chips, etc.)

---

## ðŸŽ¯ What ZMK users usually observe

For **nice!nano v2 running ZMK**, users typically report:

* **25â€“35 ÂµA idle**
* **150â€“250 ÂµA connected idle**
* **1â€“3 mA during typing bursts**

Which matches the expected behavior for the nRF52840.

---

If you want, I can help you:

* Measure your boardâ€™s actual draw
* Compare against expected values
* Optimize your ZMK config for lower power

Just tell me your board (nice!nano, custom PCB, etc.).

---

Can use TSX339 (5nA current, need 18)

or find a TI comparator here:
https://www.ti.com/product-category/amplifiers/comparators/products.html#p1typ=0.001;0.01

for nRF52840 to work efficiently, it has to sleep and be waken up every time a
key is typed (when gpio pin goes high). use a comparator for each switch
(preferably drawing <5uA), adjust the threshold using a variable volt
programmable device (not `researched yet), connect digital output of switches
in a matrix. All of this more complicated than just using ADC expanders and rp2040.

less efficient solution is to use a analog mux (they're low power) and do all
adc inside nRF52840.

----

Q: push-pull vs open-drain for ADC output

Hereâ€™s a clear, practical explanation â€” the kind you need when choosing between output types on sensors, comparators, MCUs, etc.

---

# ðŸ”Œ **Push-Pull Output**

A **push-pull** (also called *totem-pole*) output actively drives the line **both high and low**.

### What that means electrically

* It has **two transistors**:

  * one pulls the output **up to Vcc** (source current)
  * one pulls the output **down to GND** (sink current)
* The output always has a **defined state** without needing any external resistor.

### Pros

* Fast switching
* Strong high and low drive (good for high-speed digital signals)
* No external pull-up resistor needed
* Lower power consumption during switches (generally)

### Cons

* **Must NOT be connected directly in wired-OR with another push-pull output** (risk of shorting Vcc to GND).
* Canâ€™t share a line with multiple devices unless tri-stated.

### When you choose push-pull

* Directly driving digital inputs
* SPI, UART TX, most digital logic
* Clean, fast edges needed

---

# ðŸ”Œ **Open-Drain Output** (open-collector for BJTs)

An **open-drain** output *can only pull the line low*.
It **cannot** drive the line high â€” the line must go high using an **external pull-up resistor**.

### What that means electrically

* Only the **â€œlow-sideâ€ transistor** exists (connects output â†’ GND)
* To get a logic HIGH:

  * pull-up resistor pulls the line to Vcc
  * output transistor simply stays â€œoffâ€

### Pros

* Allows **multiple outputs to share one line** â†’ wired-OR / wired-AND logic
* **Level shifting is easy**:
  Pull-up can be to a different voltage (e.g., sensor at 3.3 V, MCU at 5 V)
* Very safe for mixing devices and buses (e.g., IÂ²C)

### Cons

* Needs a pull-up resistor
* Typically slower (because pull-up is passive; rising edges depend on RC time constant)
* Weak high drive (limited by pull-up value)

### When you choose open-drain

* IÂ²C
* Interrupt lines shared by multiple devices
* Safety-critical outputs where â€œfail to high-impedanceâ€ is desired
* When you need level-shifting using only a pull-up resistor

---

# âš–ï¸ **Quick side-by-side**

| Feature                    | Push-Pull | Open-Drain             |
| -------------------------- | --------- | ---------------------- |
| Drives HIGH                | Yes       | No (needs pull-up)     |
| Drives LOW                 | Yes       | Yes                    |
| Needs pull-up resistor?    | No        | Yes                    |
| Good for shared bus lines? | No        | Yes (wired-OR)         |
| Switching speed            | Fast      | Slower (depends on RC) |
| Easy level shifting        | No        | Yes                    |

---

# ðŸ’¡ Which should *you* use for a TMR â†’ comparator/sensor application?

* If you want a **clean digital logic output** feeding a microcontroller input â†’ **push-pull** is simplest.
* If multiple devices may pull the same line low, or you need **simple level shifting** â†’ **open-drain** is the right choice.
* Many comparators offer **open-drain outputs**, letting you choose the pull-up voltage and hysteresis externally.

---
---

Q:
i need to OR 72 of these outputs to find out if any one is HIGH. whic hto choose

Short answer: **Use open-drain (or open-collector) outputs tied together with a single pull-up, and treat the line as â€œactive-lowâ€** (any device pulls the line low â†’ you detect that and invert in firmware). Thatâ€™s the simplest, safest, lowest-part-count way to know â€œif any one is activeâ€ across 72 devices.

Below is why, how, and a few practical alternatives.

---

# Why open-drain (best fit for 72 outputs)

* Open-drain devices only **pull the line low**. When idle they release the line and the pull-up drives it high.
* If you tie many open-drain outputs together to a single pull-up, the common node will be **LOW if any device asserts** (pulls low). No bus contention risk â€” multiple devices pulling low is harmless.
* Minimal parts: one pull-up resistor, one line to your MCU/comparator. Very robust and scalable.

> Note: This gives you an **active-low** combined signal: `LINE = LOW` means â€œone or more assertedâ€. Read the line and invert in firmware if you prefer active-HIGH semantics.

---

# How to implement (practical steps)

1. **Configure/choose outputs as open-drain / open-collector** (or convert push-pull to open-drain using e.g. a small N-MOSFET/transistor per channel if you canâ€™t change the device).
2. Tie all 72 outputs to a single node.
3. Add **one pull-up resistor** from that node to the pull-up voltage (e.g. 3.3 V).
4. Connect that node to your MCU / comparator input (with optional Schmitt input for noise immunity).
5. In firmware: read pin; `if (pin == LOW) => /* one or more asserted */`.

---

# Pull-up selection (speed vs power tradeoff)

* Rise time is set by the RC time constant: `Ï„ = R * Cnode`. For approximate rise to logic high you need ~3Ï„.
* Typical values:

  * **Low-power**: 47 kÎ©â€“100 kÎ© â†’ very small quiescent current, slower edges.
  * **Balanced**: 10 kÎ©â€“22 kÎ© â†’ small standing current when pulled low, decent rise time for many applications.
  * **Speedy**: 1 kÎ©â€“4.7 kÎ© â†’ fast rise, but larger current when low.
* Example: if node capacitance â‰ˆ 200 pF and you want ~10 Âµs rise:

  * Choose Ï„ â‰ˆ 3.3 Âµs â†’ `R â‰ˆ Ï„ / C â‰ˆ 3.3e-6 / 200e-12 â‰ˆ 16.5 kÎ©`. So 10 kÎ©â€“22 kÎ© is reasonable.
* Pull-up current when line is pulled low: `I = Vpullup / R`. For 3.3 V and 10 kÎ© â†’ 0.33 mA (permanent while held low). Thatâ€™s the main power cost.

---

# Hysteresis / noise

* Add a Schmitt-trigger input (hardware or in your MCU) or small RC/debouncing in firmware to avoid chatter if the TMR/comparators are noisy.
* If you use an external comparator as the OR destination, choose one with Schmitt input or add small hardware hysteresis.

---

# If you **cannot** use open-drain on the sources (they are push-pull)

Options:

1. **Diode-OR** (wired-OR of highs): put a diode from each output to the common node (anode = output, cathode = common node) and a pull-down on the node. Use Schottky diodes to minimize forward drop. This creates a true OR for HIGHs but costs 72 diodes and the common node will be at (Vout âˆ’ Vf).
2. **Use an OR gate / encoder tree**: cascade many OR gates or use dedicated wide-input OR/priority-encoder ICs. This increases board area and IC count.
3. **Convert each push-pull into an open-drain** with a small transistor or FET (e.g., an N-MOSFET per channel to pull common node low). You can use an array like a transistor darlington/driver that sinks only (e.g., ULN family) if levels are OK. That keeps the single pull-up approach and avoids diode drops.
4. **Use comparators with open-drain outputs** at the sensor stage (if you can select a comparator that offers open-drain output) so they can be ORâ€™d directly.

---

# Practical recommendation (summary)

* **Best / simplest:** Make the 72 outputs open-drain (or add an N-channel FET per channel) and tie to a single pull-up (10 kÎ©â€“22 kÎ© for a good speed/power compromise). Treat the combined signal as **active-low** and invert in software.
* **If outputs are fixed push-pull and you want active-HIGH OR with minimal logic:** use **diode-OR with Schottky diodes** (72 diodes + pull-down), or convert outputs to open-drain with transistor arrays.

---

