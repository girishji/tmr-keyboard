Q: is it possible for any of newer nrf ble mcu's to still be in deep sleep but generate a pulse of 100microsec duration periodically on one of the GPIO pins

chatgpt:

Short answer: **Yes** ‚Äî modern Nordic nRF BLE MCUs can generate short (‚âà100 ¬µs) GPIO pulses while the CPU is sleeping, but *how* you do it and how much power it costs depends on which peripheral you use.

Below is a concise breakdown (what works, trade-offs, and a recommended approach).

# Options & tradeoffs

## 1) Best precision: **TIMER + PPI/DPPI + GPIOTE**

* Use a hardware TIMER to produce compare events and wire those events to GPIOTE tasks via PPI (nRF52) or DPPI (nRF53+). The TIMER -> PPI -> GPIOTE path toggles the pin entirely in hardware, so the CPU stays asleep (System **ON** sleep). This can easily produce a 100 ¬µs pulse with ¬µs (or sub-¬µs) resolution. ([Nordic Semiconductor Docs][1])
* **Cost:** TIMER runs from the HFCLK (fast clock). If you keep the TIMER running while sleeping, the HFCLK will typically remain on ‚Üí higher sleep current than pure deep sleep. Expect microamp‚Äìlevel (or higher) depending on clock/peripheral state. ([Medium][2])

## 2) Lowest-power (but coarser timing): **RTC + PPI + GPIOTE**

* The RTC runs from the LFCLK and can keep ticking while HFCLK is off. You can link RTC compare events to GPIOTE via PPI so pin set/clear happens without waking the CPU. Because RTC ticks at 32.768 kHz, its resolution is **~30.517 ¬µs**, so a 100 ¬µs pulse is feasible (3 ticks ‚âà 91.5 ¬µs, 4 ticks ‚âà 122 ¬µs) but with coarse granularity and more jitter and drift (LFCLK accuracy). This is the usual approach when you want periodic activity with minimal power. ([Nordic Semiconductor Docs][3])
* **Cost:** Much lower sleep current because HFCLK can be off; accuracy and pulse width granularity are limited by LFCLK tick size and oscillator accuracy. ([Nordic Semiconductor Docs][3])

## 3) PWM peripheral

* Nordic‚Äôs PWM (or PWM-like) peripherals can also produce pulses in hardware (internally backed by TIMERs). Same tradeoff as (1): very good timing, but typically depends on HFCLK and keeps higher-power clocks on. ([Medium][2])

## Important: **System OFF vs System ON**

* **System OFF (deepest sleep)** essentially powers down peripherals ‚Äî you **cannot** have a running TIMER/RTC/PPI producing periodic pulses in true System OFF. To do periodic, hardware-driven pulses you must be in **System ON (idle)** where peripherals can be left running. (System OFF only wakes on specific wake sources and doesn‚Äôt let peripherals keep generating events). ([Moddable][4])

# Practical recipe (two concrete choices)

### A ‚Äî Precise 100 ¬µs pulses (low jitter)

1. Configure a TIMER (runs from HFCLK) with CC0 = start, CC1 = start + pulse_width (100 ¬µs).
2. Configure GPIOTE channel for TASKS_SET and TASKS_CLEAR on the pin.
3. Connect TIMER EVENTS to those GPIOTE TASKS with PPI/DPPI channels.
4. Start the TIMER and put CPU into System ON sleep.
   Result: pulses generated by hardware; CPU sleeps. (But HFCLK will be required/kept on while TIMER runs.) ([Nordic Semiconductor Docs][1])

### B ‚Äî Lowest sleep current (approx 100 ¬µs)

1. Use RTC compare0 for rising edge, compare1 for falling edge (or chain compare+offset).
2. Configure GPIOTE TASKS and link RTC compare events to those via PPI.
3. Use LFCLK as RTC clock so HFCLK can stay off; put CPU into System ON low-power sleep.
   Result: hardware pulses while HFCLK is off ‚Üí much lower sleep current, but pulse width resolution ‚âà 30.5 ¬µs and more jitter. ([Nordic Semiconductor Docs][3])

# Which nRF chips support it?

* **nRF52 family** (nRF52832/40/20/10/etc.) ‚Äî supports TIMER + PPI + GPIOTE and RTC + PPI + GPIOTE. Proven in many examples. ([Nordic Semiconductor Docs][1])
* **nRF53 / nRF5340 / nRF54 families** ‚Äî same idea, but newer chips use DPPI and enhanced low-power peripherals; documentation shows peripheral connections and low-power modes support this pattern. If you use nRF53/5340, prefer DPPI for lower-latency and better channeling. ([Nordic DevZone][5])

# Practical notes / gotchas

* If you need **exactly 100.000 ¬µs** with low jitter, use TIMER (HFCLK) approach. If you need **ultra-low power** and can tolerate ¬±30 ¬µs quantization/jitter, use RTC approach. ([Nordic Semiconductor Docs][1])
* Make sure to configure GPIOTE to control the pin (TASK mode), and reserve enough PPI/DPPI channels for set+clear events. New chips have plenty of DPPI channels but check your exact part. ([Nordic Semiconductor Docs][6])
* If you have an active SoftDevice/Bluetooth stack, it may already use some RTCs/HF clocks ‚Äî be careful which RTC/TIMER you pick (and whether BLE will force HFCLK on periodically). ([Reichelt][7])

# Summary (tl;dr)

* **Yes** ‚Äî you can generate 100 ¬µs pulses while the CPU is asleep by wiring peripherals (TIMER/RTC) through PPI/DPPI to GPIOTE so the CPU isn‚Äôt involved. ([Nordic Semiconductor Docs][1])
* Choose **TIMER+PPI+GPIOTE** for precision (cost: HFCLK on ‚Üí higher sleep power), or **RTC+PPI+GPIOTE** for lowest power (cost: ‚âà30.5 ¬µs resolution and more jitter). **System OFF cannot** keep peripherals running for periodic pulses ‚Äî use System ON sleep. ([Nordic Semiconductor Docs][1])

---

(current consumption difference:)

## ‚ö° **Approximate Power Differences**

### üîπ **RTC + LFCLK (lowest power)**

* RTC runs directly from LFCLK (32.768 kHz).
* LFCLK can stay active while the MCU in **System ON low-power sleep**, *without powering HFCLK*.
* Current consumption for the RTC + LFCLK running is in the **~0.1‚Äì1 ¬µA range** (very low). ([Nordic DevZone][1])
* With PPI/DPPI + GPIOTE, no CPU wakeups needed: essentially **just the LF clock + minimal peripheral overhead**.

**Typical:** *~1 ¬µA or less* extra while sleeping.
(This is approximate based on typical RTC consumption and Nordic discussions about low-power RTC usage.) ([Nordic DevZone][1])

> This low number assumes LFCLK (best case external crystal), and the peripheral timers toggling pin via PPI/DPPI, not waking the CPU.

---

### üîπ **TIMER + HFCLK (precise timing)**

* TIMER requires HFCLK ‚Üí if you keep HFCLK running while sleeping, that results in **much higher idle current**.
* HFCLK active current varies a bit by part and clock source (crystal vs internal RC), but it *usually* dominates sleep current.

Typical HFCLK running currents seen in Nordic discussions:

* **~500 ¬µA** (0.5 mA) is mentioned as a ballpark when HFCLK + TIMER/PWM are kept active continuously. ([Nordic DevZone][2])
* Another discussion notes **5 ‚Äì 70 ¬µA just for the TIMER itself**, *plus* the HF crystal load current on top of that. ([Nordic DevZone][1])

So in practice:
**Typical:** *tens to hundreds of ¬µA* ‚Äî up to around **0.5 mA** if the HFCLK crystal is running and the TIMER is continuously used.

---

## üìä **Summary of Typical Sleep Currents**

| Method                         | Sleep Mode        | Clock Required             | Approx. Sleep Current                             |
| ------------------------------ | ----------------- | -------------------------- | ------------------------------------------------- |
| **RTC + LFCLK (PPI + GPIOTE)** | System ON (sleep) | LFCLK only (no HF)         | **~1 ¬µA or less**                                 |
| **TIMER + HFCLK**              | System ON (sleep) | HFCLK running continuously | **~tens to hundreds of ¬µA**, possibly **~500 ¬µA** |

---
----
----

chatgpt:

Q:
give a small register-level snippet or nrfx/SDK code (TIMER+PPI+GPIOTE or RTC+PPI+GPIOTE) for whichever nRF model you plan to use, and target nRF54 ‚Äî produce example code now. also, is it better to use zephyr or use nrfx SDK

Below is a **minimal, concrete example for nRF54** showing **RTC + DPPI + GPIOTE** (lowest-power option) at **register / nrfx level**, followed by a short **TIMER + DPPI** variant for reference. Then I‚Äôll answer **Zephyr vs nrfx** clearly.

I‚Äôll assume:

* **nRF54L / nRF54H family**
* Using **nrfx HAL** (no Zephyr abstractions)
* LFCLK already started (external 32.768 kHz crystal preferred)
* Output pulse ‚âà **100 ¬µs** (quantized by RTC tick)

---

# Option A (recommended for low power): **RTC + DPPI + GPIOTE (TASK SET/CLEAR)**

### Timing

* LFCLK = 32,768 Hz ‚Üí **30.52 ¬µs per tick**
* 100 ¬µs ‚âà **3 ticks** (‚âà91.5 ¬µs) or **4 ticks** (‚âà122 ¬µs)

Below uses **3 ticks**.

---

## 1Ô∏è‚É£ GPIOTE: configure pin as TASK-controlled output

```c
#include <nrfx.h>

#define PULSE_PIN  10   // GPIO number

void gpiote_init(void)
{
    NRF_GPIOTE->CONFIG[0] =
        (GPIOTE_CONFIG_MODE_Task << GPIOTE_CONFIG_MODE_Pos) |
        (PULSE_PIN << GPIOTE_CONFIG_PSEL_Pos) |
        (GPIOTE_CONFIG_POLARITY_None << GPIOTE_CONFIG_POLARITY_Pos) |
        (GPIOTE_CONFIG_OUTINIT_Low << GPIOTE_CONFIG_OUTINIT_Pos);
}
```

This gives you:

* `TASKS_SET[0]`
* `TASKS_CLR[0]`

---

## 2Ô∏è‚É£ RTC: periodic compare events

```c
#define RTC_INSTANCE NRF_RTC0
#define PULSE_WIDTH_TICKS  3      // ‚âà 91.5 ¬µs
#define PERIOD_TICKS       32768  // 1 second

void rtc_init(void)
{
    RTC_INSTANCE->PRESCALER = 0;  // full 32.768 kHz

    RTC_INSTANCE->CC[0] = 0;                    // rising edge
    RTC_INSTANCE->CC[1] = PULSE_WIDTH_TICKS;    // falling edge
    RTC_INSTANCE->CC[2] = PERIOD_TICKS;         // next period

    RTC_INSTANCE->EVTENSET =
        RTC_EVTENSET_COMPARE0_Msk |
        RTC_EVTENSET_COMPARE1_Msk |
        RTC_EVTENSET_COMPARE2_Msk;

    RTC_INSTANCE->TASKS_CLEAR = 1;
    RTC_INSTANCE->TASKS_START = 1;
}
```

---

## 3Ô∏è‚É£ DPPI: connect RTC events ‚Üí GPIOTE tasks

```c
void dppi_init(void)
{
    uint8_t ch0 = 0;
    uint8_t ch1 = 1;
    uint8_t ch2 = 2;

    // Rising edge
    NRF_DPPIC->CH[ch0].EEP = (uint32_t)&RTC_INSTANCE->EVENTS_COMPARE[0];
    NRF_DPPIC->CH[ch0].TEP = (uint32_t)&NRF_GPIOTE->TASKS_SET[0];

    // Falling edge
    NRF_DPPIC->CH[ch1].EEP = (uint32_t)&RTC_INSTANCE->EVENTS_COMPARE[1];
    NRF_DPPIC->CH[ch1].TEP = (uint32_t)&NRF_GPIOTE->TASKS_CLR[0];

    // Period reload
    NRF_DPPIC->CH[ch2].EEP = (uint32_t)&RTC_INSTANCE->EVENTS_COMPARE[2];
    NRF_DPPIC->CH[ch2].TEP = (uint32_t)&RTC_INSTANCE->TASKS_CLEAR;

    NRF_DPPIC->CHENSET =
        (1UL << ch0) |
        (1UL << ch1) |
        (1UL << ch2);
}
```

---

## 4Ô∏è‚É£ Main

```c
int main(void)
{
    gpiote_init();
    rtc_init();
    dppi_init();

    while (1)
    {
        __WFE();   // System ON sleep, CPU idle
    }
}
```

### ‚úÖ Result

* CPU sleeps continuously
* LFCLK only
* Hardware produces periodic ~100 ¬µs pulse
* **~1 ¬µA class sleep current**

---

# Option B (precision): **TIMER + DPPI + GPIOTE**

Use this **only if you need exact 100.000 ¬µs**.

Key differences:

* TIMER clocked by **HFCLK**
* Higher sleep current (10√ó‚Äì1000√ó)

```c
NRF_TIMER0->MODE = TIMER_MODE_MODE_Timer;
NRF_TIMER0->BITMODE = TIMER_BITMODE_BITMODE_32Bit;
NRF_TIMER0->PRESCALER = 4; // 1 MHz timer (1 ¬µs ticks)

NRF_TIMER0->CC[0] = 0;
NRF_TIMER0->CC[1] = 100;  // 100 ¬µs
NRF_TIMER0->CC[2] = 1000000; // 1 second

NRF_TIMER0->SHORTS = TIMER_SHORTS_COMPARE2_CLEAR_Msk;
```

Then DPPI wiring is identical to the RTC example.

---

# Zephyr vs nrfx SDK (clear answer)

### ‚úÖ **Use nrfx (or bare HAL) if:**

* You care about **absolute minimum power**
* You need **tight control of clocks**
* You want **pure hardware behavior**
* You don‚Äôt want OS scheduling jitter

‚û°Ô∏è **This pulse-generation use case fits nrfx perfectly**

---

### ‚ö†Ô∏è Zephyr is *possible*, but:

* Zephyr **does not expose DPPI + GPIOTE + RTC cleanly**
* You‚Äôll still drop to **nrfx underneath**
* Zephyr keeps extra infrastructure alive
* More complexity, slightly higher baseline current

‚û°Ô∏è Zephyr is better when:

* BLE + networking + drivers + threads
* You need portability and device-tree abstraction

---

# üîë Recommendation

For **nRF54 + ultra-low-power pulse generation**:

> **Use nrfx / register-level code.**
> Zephyr adds little value and complicates clock/power control.

---

If you want, I can:

* Convert this to **pure register-only (no nrfx headers)**
* Adjust for **nRF54H vs nRF54L**
* Compute **average current** for your pulse period
* Add **BLE coexistence-safe configuration**



----
---
---

gemini:

Yes, it is possible to achieve this on newer nRF SoCs like the **nRF54L15** and the **nRF52 Series** using a combination of their low-power peripherals, primarily the **Timer** and the **Programmable Peripheral Interconnect (PPI/DPPI)**.

The key is to leverage the architecture to generate the pulse **without waking up the main CPU**.

### The Low-Power Mechanism (Timer + PPI/DPPI)

To maintain a very low sleep current, you need the main CPU to be in a deep sleep state (like **System ON Idle** or **System OFF** with RAM retention) and use low-power, autonomous peripherals to handle the I/O task.

#### 1. The Clock and Timer

You use a low-frequency clock source (like the internal or external **32.768 kHz LFCLK**) to run a persistent, low-power timer.

* **GRTC (Global Real-Time Clock) / RTC:** The nRF54L15 introduces the **GRTC**, which is ideal for this. It can run continuously in the deepest sleep modes and be configured to generate a periodic event.
* **Target:** Configure the Timer to generate a **COMPARE event** periodically (e.g., every 5 seconds, 1 minute, etc., which is your pulse repetition rate).

#### 2. The GPIOTE and PPI/DPPI

The magic happens when you connect the Timer's event directly to the GPIO output logic using the **PPI (Programmable Peripheral Interconnect)** system (or **DPPI** for the nRF54L15/nRF5340).

* **GPIOTE (GPIO Tasks and Events):** This peripheral controls the physical GPIO pins. It has tasks for setting, clearing, and toggling a pin.
* **The Chain:** You set up two PPI channels to create the 100 $\mu$s pulse:

| Step | Peripheral | Action | Duration |
| :--- | :--- | :--- | :--- |
| **Start Pulse** | **GRTC COMPARE Event** $\rightarrow$ **PPI Channel 1** | **$\rightarrow$ GPIOTE Task SET** | Pin goes **High** |
| **End Pulse** | **Timer (High-Speed)** **COMPARE Event** $\rightarrow$ **PPI Channel 2** | **$\rightarrow$ GPIOTE Task CLEAR** | Pin goes **Low** |

**How the 100 $\mu$s Pulse is Achieved:**

1.  The **GRTC** (running on LFCLK) generates a periodic event to start the cycle.
2.  **PPI Channel 1** is triggered by the GRTC event, which executes a **GPIOTE SET** task, making the pin **HIGH**.
3.  Simultaneously, the GRTC event also triggers a **High-Speed Timer** (e.g., TIMER0, running on HFCLK) to start a **one-shot** sequence.
4.  This **High-Speed Timer** is configured to generate an event exactly **100 $\mu$s** after it is started.
5.  **PPI Channel 2** is triggered by the High-Speed Timer's 100 $\mu$s COMPARE event, which executes a **GPIOTE CLEAR** task, making the pin **LOW**.

### üí° Why this works in Deep Sleep

This entire sequence of events‚Äîthe periodic trigger, the high-speed timing, and the GPIO change‚Äîis managed by the autonomous peripherals and the PPI/DPPI matrix. The main **CPU core remains asleep** (System ON Idle or similar low-power state) and is never woken up, allowing the device to maintain its ultra-low sleep current while autonomously generating the required pulses.

---

### Which Deep Sleep Mode?

| Mode | CPU State | Peripheral State | Power Consumption | Pulse Generation? |
| :--- | :--- | :--- | :--- | :--- |
| **System OFF** | Completely Powered Down (Resets on wakeup) | Only a few registers/GPIO retained. | Lowest (Sub- $\mu$A) | **NO.** Peripherals (like Timer, PPI, GPIOTE) are powered off. |
| **System ON Idle** | Sleeping, but RAM/Peripherals Powered | LFCLK, Timer, PPI, GPIOTE remain active. | Ultra-Low (Low $\mu$A) | **YES.** This is the correct mode. |

For this application, you will be in the **System ON Idle** mode, which is the Nordic term for the lowest power state where the peripherals and RAM are still powered and clocked by the LFCLK.

Would you like to know the typical current consumption increase you might expect when running the GRTC and a high-speed timer periodically?


---
---

Q: can nrf be used to pulse TMR sensors

Yes, absolutely. This is one of the core strengths and design philosophies of the $\text{nRF}52$ series of microcontrollers, particularly when used in low-power wireless applications like keyboards.

The $\text{nRF}52$ MCUs use a sophisticated power management system that allows the main CPU core (the $\text{ARM}$ $\text{Cortex}$-$\text{M}$ series processor) to enter a deep sleep state while specific, ultra-low power peripherals remain running.

Here is how the $\text{nRF}52$ achieves a low-power timer for pulsing sensors:

## üí§ System $\text{ON}$ Low-Power Mode

The $\text{nRF}52$ MCUs spend most of their time in the **System $\text{ON}$ low-power mode**. Within this mode, the CPU can execute a **`WFE` (Wait For Event)** or **`WFI` (Wait For Interrupt)** instruction, putting the core into a deep sleep state.

The key to your requirement is the use of the **Low-Frequency Clock (LFCLK)** domain.

### 1. The Low-Frequency Clock (LFCLK)

The $\text{nRF}52$ family has two primary clock sources:

* **High-Frequency Clock ($\text{HFCLK}$):** Used to run the main $\text{CPU}$ core and the high-speed peripherals (like $\text{Bluetooth}$) at full speed ($\approx 64 \text{ MHz}$). This is powered down in sleep mode.
* **Low-Frequency Clock ($\text{LFCLK}$):** Used to run the ultra-low power peripherals at $\mathbf{32.768 \text{ kHz}}$. This clock can remain running with extremely low power consumption (drawing only a few nanoamperes) while the $\text{CPU}$ is sleeping.

### 2. The RTC (Real-Time Counter) Peripheral

The $\text{nRF}52$ uses its **$\text{RTC}$ (Real-Time Counter)** peripheral, which is driven by the $\text{LFCLK}$, as the core timing mechanism.

* The $\text{RTC}$ is designed to operate continuously.
* You configure the $\text{RTC}$ to generate an **interrupt** every $10 \text{ ms}$.
* When the $\text{CPU}$ is sleeping, the $\text{RTC}$ continues to count. When the $10 \text{ ms}$ target is reached, the $\text{RTC}$ generates a wake-up signal (an interrupt).

### 3. The Pulsing Procedure

The entire process for pulsing your $\text{TMR}$ sensor every $10 \text{ ms}$ while minimizing power consumption is handled by the $\text{MCU}$'s architecture:

| Time | MCU State | Action | Power Consumption |
| :--- | :--- | :--- | :--- |
| **$0 \text{ ms}$** | **Wakes Up** | $\text{RTC}$ interrupt fires. $\text{CPU}$ wakes up. | $\text{High}$ ($\text{mA}$) |
| **$0 \to 100 \mu\text{s}$**| **Active** | 1. $\text{CPU}$ sets $\text{GPIO}$ HIGH (power on sensor). 2. $\text{CPU}$ enters short $100 \mu\text{s}$ delay. 3. $\text{CPU}$ reads sensor data. 4. $\text{CPU}$ sets $\text{GPIO}$ LOW (power off sensor). | $\text{High}$ ($\text{mA}$) |
| **$100 \mu\text{s}$ to $10 \text{ ms}$** | **Deep Sleep** | $\text{CPU}$ executes `WFE`/`WFI`. $\text{CPU}$ sleeps. **$\text{RTC}$ continues counting.** | **Ultra-Low** ($\mu\text{A}$) |

---

## Conclusion

Every $\text{nRF}52\text{x}$ $\text{MCU}$ (including the popular $\text{nRF}52840$ and $\text{nRF}52832$) is designed to allow the **$\text{RTC}$ (timer) to run while the main $\text{CPU}$ core is asleep**. This is the standard, highly efficient way to implement periodic polling in ultra-low power wireless applications like your keyboard.

The power consumption of the $\text{nRF}52$ in this sleep state is typically in the **low single-digit microamperes** ($2 \mu\text{A}$ to $5 \mu\text{A}$), which is the most efficient solution available for this task.

---
---

Q: does nordic make a ldo for low power operations

Good question. Yes ‚Äî Nordic Semiconductor does offer dedicated power-management ICs (PMICs) that provide LDO (and other) regulation, designed for low-power and battery-operated devices. ([nordicsemi.com][1])

### ‚úÖ Nordic‚Äôs PMIC solutions with LDO / low-power support

* **nPM2100** ‚Äî a newer PMIC from Nordic. It includes a highly efficient boost regulator (for raising battery voltage to a usable rail) and a built-in LDO / load-switch output that can supply up to ~50 mA. ([nordicsemi.com][2])
* **nPM1300** ‚Äî an earlier Nordic PMIC, providing multiple regulated rails via external DC/DC or LDO regulators. It integrates 2 step-down DC/DC converters plus 2 LDO regulators, battery charging and power-path management, meant to simplify supply design for Nordic SoCs. ([electronicsforu.com][3])

These PMICs are explicitly targeted at battery-powered, low-power embedded designs (e.g. wearables, sensors, BLE modules), and are well suited to use with Nordic SoCs (e.g. the nRF52840) to supply the MCU, radios, sensors, and optionally external modules ‚Äî all under a unified, power-efficient supply solution. ([nordicsemi.com][1])

---

## ‚úÖ From Nordic (very well matched to nRF + BLE + battery)

* **nPM2100** ‚Äî boost regulator + LDO/load-switch ideal for single-cell or coin-cell battery powered BLE devices. Input range 0.7‚Äì3.4 V, output 1.8‚Äì3.3 V, up to 150 mA (boost) or 50 mA (LDO), quiescent current down to ~150 nA. Supports ‚Äúship/hibernate‚Äù modes for ultra-low standby draw. ([nordicsemi.com][1])
* **nPM1300** ‚Äî more feature-rich PMIC with dual buck regulators (each up to 200 mA), 2 LDO/load switches (50 mA), battery charger, fuel-gauge, system management, USB-charging support. Good when you want to support rechargeable battery + regulated rails + external sensors/modules. ([docs-be.nordicsemi.com][2])

**Why these are good:** They are designed specifically for use with nRF-series SoCs, support typical battery chemistries, handle both boost (for low-voltage cells) and buck/LDO, include power-management features like ship mode (very low quiescent), and even battery charging / fuel gauge in nPM1300.

---

### Quick notes on some:

* **[STMicroelectronics LD2980ABM33TR](https://estore.st.com/en/ld2980abm33tr-cpn.html?utm_source=chatgpt.com)** ‚Äî simple 3.3 V LDO regulator, small, low cost, good for powering sensors or small peripherals when your battery is modestly above 3.3 V.
* **[STMicroelectronics LD2981ABU33TR](https://estore.st.com/en/ld2981abu33tr-cpn.html?utm_source=chatgpt.com)** ‚Äî another low-dropout 3.3 V regulator variant ‚Äî useful when you need a stable 3.3 V rail for sensors or logic and battery max ~4.2 V (like Li-ion).
* **[1‚ÄØA Low Quiescent Current Low‚ÄëNoise Voltage Regulator](https://www.electromaker.io/shop/product/1-a-low-quiescent-current-low-noise-voltage-regulator-with-soft-start-automotive-grade?utm_source=chatgpt.com)** ‚Äî for slightly heavier loads or peripherals needing more current, but within modest current consumption range.
* **[Texas Instruments TPS62665YFFT](https://www.utmel.com/productdetail/texasinstruments-tps62665yfft-7763667?utm_source=chatgpt.com)** ‚Äî a buck converter / PMIC (not just LDO) ‚Äî more efficient than LDO at higher currents or when battery is significantly above the required rail, useful if you care about efficiency and battery life.

**Good for:** powering sensors or small modules when you want regulated 3.0‚Äì3.3 V and don‚Äôt need all the bells & whistles of a full PMIC. Often simpler, cheaper, and with lower board footprint.

---

## ‚öôÔ∏è When to pick which kind of regulator / PMIC

| Situation                                                                                                                        | Recommended type                                     |
| -------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| Single-cell coin battery / AA / small battery; need boost + regulated rail + lowest quiescent current + simple BLE + sensors     | nPM2100                                              |
| Rechargeable battery (Li-ion, Li-Po), need charging, multiple rails for MCU + sensors + maybe peripherals (display, radio, etc.) | nPM1300                                              |
| Already have a stable battery volt > needed sensor voltage, need simple 3.3 V supply for sensor/peripherals                      | Simple LDO (e.g. LD2980, LD2981)                     |
| Medium to high current draw, and efficiency matters (battery life, heat)                                                         | Buck converter / efficient regulator (e.g. TPS62665) |
| Low current, noise-sensitive sensors or analog modules needing clean 3.3 V rail                                                  | Low-noise LDO                                        |

---

## üìå My recommendation (based on what you‚Äôve told me so far)

Since you are using nRF + battery + external sensors, but likely want to keep overall current low and battery life high:

* If you want **maximum simplicity and lowest quiescent current** ‚Üí go with **nPM2100**.
* If you plan a **rechargeable design**, or multiple peripherals (sensors, maybe display, sensor array) ‚Üí choose **nPM1300**.
* If you just need to power a small sensor from e.g. a Li-ion battery ‚Üí a simple 3.3 V LDO like **LD2981** or **LD2980** might suffice.

----
---

Q: How much current?

---
---

Here are the **typical real-world current-draw numbers** for an **nRF52840 running ZMK**, based on common keyboard PCB designs (nice!nano v2, ZMK power-profiles, etc.):

---

## ‚úÖ **Normal Current Draw for nRF52840 in ZMK**

These are *typical* values when the board is configured correctly (deep sleep, no OLED, no extra sensors):

### **Idle (deep sleep / standby)**

* **8‚Äì15 ¬µA** for a fully optimized ZMK build
* **20‚Äì40 ¬µA** is common on real boards with regulators, power rails, etc.
* A poorly designed PCB or ESD chips may raise this into the **80‚Äì200 ¬µA** range.

### **Advertising (BLE not connected)**

* **150‚Äì450 ¬µA average**, depending on:

  * Advertising interval
  * TX power setting
  * Board hardware setup

### **Connected (normal operation)**

* **90‚Äì300 ¬µA average** with:

  * Standard ZMK BLE connection interval
  * No heavy peripherals
  * Keyboard idle (no keypresses)

### **Active typing**

* **1‚Äì3 mA** momentary peaks
* Very brief‚Äîaverage over time stays low.

### **Absolute peak events**

* **5‚Äì8 mA** radio TX spike
* Only milliseconds long
* Doesn‚Äôt significantly affect average battery life.

---

## üéØ What ZMK users usually observe

For **nice!nano v2 running ZMK**, users typically report:

* **25‚Äì35 ¬µA idle**
* **150‚Äì250 ¬µA connected idle**
* **1‚Äì3 mA during typing bursts**

Which matches the expected behavior for the nRF52840.

---


---

Q: COMP based solution

This is a great continuation of the design process. Now that you have a large matrix ($9 \times 8 = 72$ keys) and the core strategy of **power-gated, periodic scanning**, we can look at the role of the $\text{COMP}$ (Standard Comparator) versus the $\text{LPCOMP}$.

Since you are already using a **periodic scan** driven by the $\text{GRTC}$ timer, you are relying on the $\text{MCU}$ waking up and performing a fast check. In this scenario, you are essentially trading a little more power during the brief scan window for much faster, more stable checking.

### The Role of $\text{COMP}$ in Your $9 \times 8$ Matrix

Yes, you can absolutely use the **Standard $\text{COMP}$** peripheral instead of the $\text{LPCOMP}$ during your active scan phase. In fact, for a high-speed sequential scan, the $\text{COMP}$ is often a **better fit** than the $\text{LPCOMP}$.

Here is a breakdown of why:

| Component | Use Case | Power Draw | Speed/Stability |
| :--- | :--- | :--- | :--- |
| **LPCOMP** | Continuous, autonomous monitoring in deep sleep. | **$\approx 1 \text{ } \mu\text{A}$** | Slower (microsecond response) |
| **COMP** | High-speed comparison when $\text{MCU}$ is awake. | $\approx 20 \text{ } \mu\text{A}$ (but only for a few $\text{ms}$) | **Faster** (nanosecond response) |

#### Why $\text{COMP}$ Might Be Better for Active Scanning

Your scan loop needs to be as fast as possible to minimize the time the $\text{MCU}$ is awake and the TMR sensors are powered ON.

1.  **Faster Response:** The $\text{COMP}$ has a much faster response time (nanoseconds) than the $\text{LPCOMP}$ (microseconds). While the difference is small, multiplying it by $9 \times 8 = 72$ key checks can slightly reduce the total scan time, saving power.
2.  **Stability:** The $\text{COMP}$ is generally designed to be more robust for quick, consecutive measurements.
3.  **No Power Trade-off:** Since the $\text{MCU}$ is already woken up by the $\text{GRTC}$ timer and is powering the TMR bank, the slight increase in power drawn by the $\text{COMP}$ over the $\text{LPCOMP}$ during the few $\text{ms}$ of the scan is negligible compared to the power saved by having the TMR banks $\text{OFF}$ most of the time.

### The $9 \times 8$ Scanning Strategy Refined

Here is how the $\text{COMP}$ (or $\text{LPCOMP}$) would fit into your $9 \times 8$ matrix design:

#### Phase 1: Deep Sleep

* **Primary Wakeup Source:** $\text{GRTC}$ timer fires every $50 \text{ ms}$ (or similar).
* **Power:** All TMR banks are $\text{OFF}$. $\text{COMP}$ and $\text{SAADC}$ are $\text{OFF}$.

#### Phase 2: Active Scan Cycle (Using COMP/LPCOMP)

The $\text{MCU}$ wakes up and begins a two-layered loop:

1.  **Bank Loop (9 times):** Loop through the 9 banks.
    * **Bank Power:** Set $\text{GPIO}_{\text{Bank\_ENABLE}}$ $\text{HIGH}$ for the current bank.
    * **Wait:** Wait a short time for the TMR sensors' power rail to stabilize (settling time).
2.  **Pin Loop (8 times):** Loop through the 8 $\text{AIN}$ pins connected to the current bank.
    * **Select Channel:** Write the $\text{AIN}$ pin to the **$\text{COMP.PSEL}$** register.
    * **Threshold Check:** Read the **$\text{COMP.RESULT}$** register.
    * **If $\text{HIGH}$:** **Key Press Detected!** Break the inner loop and proceed to Phase 3.

#### Phase 3: ADC Verification

* The $\text{MCU}$ enables the $\text{SAADC}$ and immediately reads the precise voltage of the 8 $\text{AIN}$ pins associated with the triggered bank.
* This $\text{ADC}$ reading confirms which specific key(s) are pressed and provides the robust debouncing and matrix decoding data.

### Summary

For your $9 \times 8$ periodic scanning problem:

* **The $\text{COMP}$ is a viable and potentially faster alternative to the $\text{LPCOMP}$ for the quick threshold checking** *within* your active scan loop.
* The fundamental low-power principle remains: **The $\text{GRTC}$ timer** wakes the $\text{MCU}$, and the **TMR sensors are power-gated.**
* The **$\text{SAADC}$** is still necessary for decoding **simultaneous key presses** and providing robust, high-accuracy verification.

The choice between $\text{COMP}$ and $\text{LPCOMP}$ during the brief scan is a minor optimization, but either one is vastly superior to trying to use the $\text{ADC}$'s full sampling sequence for the initial threshold check.

----
----

